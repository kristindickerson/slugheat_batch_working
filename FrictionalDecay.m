%%% =======================================================================
%%   Purpose: 
%      This function computes equilibrium temperatures for each sensor 
%%   Last edit:
%       08/11/2023 by Kristin Dickerson, UCSC
%%% =======================================================================

function [NumberOfFricUsedPoints, ...
        MinimumFricEqTemp, ...
        MinimumFricError, ...
        MinimumFricDelays, ...
        MinimumFricSlope, ...
        HPTooLow, ...
        ShiftedTime, ...
        IndexOfMinimums, ...
        DataTemp, ...
        TimeShifts, ...
        ShiftedTau, ...
        DataFAT, ...
        DataLimits, ...
        b, ...
        a, ...
        RMS...
        ] = FrictionalDecay( ...
        figure_Main, ...
        FricTime, ...
        FricTemp, ...
        NumberOfSensors, ...
        FrictionalDelays, ...
        FricMaxStep, ...
        TimeInc, ...
        Currentk, ...
        HyndmanCoeffs, ...
        SensorRadius, ...
        FricTauMin, ...
        FricTauMax, ...
        SensorsToUse, ...
        loading, ...
        A, ...
        B, ...
        C, ...
        D, ...
        E, ...
        F,...
        ShiftedRelativeDepths,...
        RelativeDepths,PenFileName)


  %% COMPUTE                  

        %% Initialize processing
        
        load('SlugHeat22.mat', 'Tau00Data', 'FAT00')
        
        NumberOfSensorsUsed = length(SensorsToUse);
        
        DataTime = repmat(FricTime,1,NumberOfSensorsUsed);
        DataTemp = NaN*ones(size(FricTemp(:,SensorsToUse)));
        HC = HyndmanCoeffs;
        Kappa = 1e-6*Currentk(SensorsToUse)./(HC(1) ...
            - HC(2)*Currentk(SensorsToUse) ...
            + HC(3)*Currentk(SensorsToUse).^2);
        Kappa = repmat(Kappa,length(FricTime),1);
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % AF 9/02  If statement added to handle negative Kappa values. 
        %          These are bogus but they can be created if there are 
        %          thermistors that don't penetrate, and iteration using
        %          these values results in negative conductivities.
        %          It would be ideal to modify this later so that negative 
        %          k values are are trapped and reset to initial values. 
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        LowestK=min(min(Kappa));
        if LowestK < 0
            if ~isempty(ShiftedRelativeDepths)
                     Currentk(all(Kappa<0))=A + ...
                     B*ShiftedRelativeDepths(all(Kappa<0)) + ...
                     C*ShiftedRelativeDepths(all(Kappa<0)).^2 + ...
                     D*exp(E*ShiftedRelativeDepths(all(Kappa<0))) + ... 
                     F*log10(ShiftedRelativeDepths(all(Kappa<0)));
            else
                     Currentk(all(Kappa<0))=A + B*RelativeDepths(all(Kappa<0)) + ...
                     C*RelativeDepths(all(Kappa<0)).^2 + ...
                     D*exp(E*RelativeDepths(all(Kappa<0))) + ...
                     F*log10(RelativeDepths(all(Kappa<0)));
            end
            Kappa = 1e-6*Currentk(SensorsToUse)./(HC(1) ...
                - HC(2)*Currentk(SensorsToUse) ...
                + HC(3)*Currentk(SensorsToUse).^2);
            Kappa = repmat(Kappa,length(FricTime),1);
        end
        
        DataTau = Kappa.*DataTime/SensorRadius.^2;
        
        %% Truncate Data to selected dimensionless time (Tau) window
        % ------------------------------------------------------------
        
        [i,j] = find(DataTau > FricTauMin & DataTau < FricTauMax);
        DataTemp(i,j) = FricTemp(i,SensorsToUse(j)'); 
        
        %% Compute time shifts
        % -------------------
        
        TimeShifts = repmat(FrictionalDelays(SensorsToUse), [FricMaxStep 1]) ...
            + repmat(TimeInc*(1:FricMaxStep)', [1 NumberOfSensorsUsed]);
        
        ShiftedTime = repmat(FrictionalDelays(SensorsToUse),[length(FricTime) 1 FricMaxStep]) ...
            + repmat(FricTime,[1 NumberOfSensorsUsed FricMaxStep]) ...
            + repmat(permute(TimeInc*(1:FricMaxStep),[3 1 2]),[length(FricTime) NumberOfSensorsUsed 1]);
        
        %% Compute dimensionless time (Tau) Data
        % ---------------------------------------
        
        KappaMatrix = repmat(Kappa,[1 1 FricMaxStep]);
        ShiftedTau = KappaMatrix.*ShiftedTime/SensorRadius^2;
        ShiftedTauIndex = round(ShiftedTau/Tau00Data(2));
        
        ShiftedTauIndex(ShiftedTauIndex > Tau00Data(3)/Tau00Data(2)) = length(FAT00) + 1;
        ShiftedTauIndex(ShiftedTauIndex < 1) = length(FAT00) + 2;
        FAT00(end+1) = 9;   
        FAT00(end+1) = NaN; 
        
        %Try to get all data in the tau window. If fails, tell user they
        % need to check their input parameters to avoid program failure
        %try
            DataFAT = FAT00(ShiftedTauIndex);
        %catch
        %    whichsens      = find(all(all(isnan(DataTemp)),3));
        %    disp(['Program failure. ' ...
        %        newline newline  ['Check the following data to ensure ' ...
        %        'program feasibility:'] ...
        %        newline newline ...
        %        '- Ensure all input parameters are correct.' ...
        %        newline newline ...
        %        '- Ensure bottom water is correct.' ...
        %        newline newline ...
        %        ['- Ensure bad data is ignored. To ignore spurious data, ' ...
        %        'you may need to move the timing of events such as the ' ...
        %        'start of penetration, heat pulse, or end of penetration.' ...
        %        ' Use the text boxes in the command window to left.'] ...
        %        newline newline ...
        %        ['- If all paramters are correct and data time windows ' ...
        %        'are all correct, you may need to remove a sensor entirely. ' ...
        %        'If a sensor did not penetrate and was recording bottom ' ...
        %        'water temperature, the program could fail. This sensor ' ...
        %        'has no measurements in the required \tau range: '] ...
        %        num2str(whichsens) newline ['You may need to discard all ' ...
        %        'data from this sensor to proceed.'] newline newline  ...
        %        '- Finally, ensure data is within required \tau range. ' ...
        %        'Check heat pulse power, as this affects \tau. ' ...
        %        'If the heat pulse power is too low, you must raise ' ...
        %        'power or ignore the heat pulse reduction. ' ...
        %        'For sensitivity analysis, check minimum thermal ' ...
        %        'conductivity values ' ...
        %        'for each sensor. Your minimum may be too low.' newline])
        %    clc;
        %    clf reset;
        %    close all hidden;
        %    clear variables;
        %    more off;
        %    echo off all;
        %    fclose('all'); 
        %    return
        %end
        
        iDF = find(DataFAT>8);
        DataFAT(iDF) = 1./(4*ShiftedTau(iDF))-1./(8*ShiftedTau(iDF).^2);
        DataTemp = repmat(DataTemp,[1 1 FricMaxStep]);
        
        %% Compute chi-square fits
        % -----------------------
        
        [ix,~] = find(~isnan(DataFAT));
        [iy,~] = find(~isnan(DataTemp));
        
        DataLimits = [max([min(ix) min(iy)]) min([max(ix) max(iy)])];
        NumberOfFricUsedPoints = 1+diff(DataLimits);
        clear ix iy jx jy
        
        
        X = reshape(DataFAT(DataLimits(1):DataLimits(2),:,:), ...
            [NumberOfFricUsedPoints NumberOfSensorsUsed*FricMaxStep]);
        Y = reshape(DataTemp(DataLimits(1):DataLimits(2),:,:), ...
            [NumberOfFricUsedPoints NumberOfSensorsUsed*FricMaxStep]);
        
        % If one or more sensors is completely out of tau range, all
        % ShiftedTaunIndex will be NaN - this causes code to break
        
        %try
            [a,b,~,~,Chi2] = ChiSquaredFit(X,Y);
        %catch
        %    whichsens      = find(all(all(isnan(DataTemp)),3));
        %    disp(['\bfError! Program failure. ' ...
        %        newline newline ...
        %        'Check the following data to ensure program feasibility:' ...
        %        newline newline ...
        %        '- Ensure all input parameters are correct.' ...
        %        newline newline ...
        %        '- Ensure bottom water is correct.' ...
        %        newline newline ...
        %        ['- Ensure bad data is ignored. To ignore spurious data, ' ...
        %        'you may need to move the timing of events such as the ' ...
        %        'start of penetration, heat pulse, or end of penetration. ' ...
        %        'Use the text boxes in the command window to left.'] ...
        %        newline newline ...
        %        ['- If all paramters are correct and data time windows ' ...
        %        'are all correct, you may need to remove a sensor entirely. ' ...
        %        'If a sensor did not penetrate and was recording bottom ' ...
        %        'water temperature, the program could fail. This sensor' ...
        %        ' has no measurements in the required \tau range: '] ...
        %        num2str(whichsens) newline ['You may need to discard all ' ...
        %        'data from this sensor to proceed.'] newline newline  ...
        %        '- Finally, ensure data is within required \tau range. ' ...
        %        'Check heat pulse power, as this affects \tau. ' ...
        %        'If the heat pulse power is too low, you must raise ' ...
        %        'power or ignore the heat pulse reduction. ' ...
        %        'For sensitivity analysis, check minimum thermal ' ...
        %        'conductivity values ' ...
        %        'for each sensor. Your minimum may be too low.' newline])
        %    HPTooLow = 1;
        %    return
        %end
        clear X Y
        
        a = reshape(a,[NumberOfSensorsUsed FricMaxStep]);
        b = reshape(b,[NumberOfSensorsUsed FricMaxStep]);
        
        Chi2 = reshape(Chi2,[NumberOfSensorsUsed FricMaxStep]);
        RMS = sqrt(Chi2/(NumberOfFricUsedPoints/2));
        
        % Compute Errors and Standard deviation
        % -------------------------------------
        
        MinimumFricError = NaN*ones(NumberOfSensors,1);
        MinimumFricDelays = NaN*ones(NumberOfSensors,1);
        MinimumFricEqTemp = NaN*ones(NumberOfSensors,1);
        MinimumFricSlope = NaN*ones(NumberOfSensors,1);
        
        [Minimums,IndexOfMinimums] = min(2*RMS,[],2);
        MinimumFricError(SensorsToUse) = Minimums;
        MinimumFricDelays(SensorsToUse) = diag(TimeShifts(IndexOfMinimums,:));    
        MinimumFricEqTemp(SensorsToUse) = diag(a(:,IndexOfMinimums));
        MinimumFricSlope(SensorsToUse) = diag(b(:,IndexOfMinimums));
        
        % If one or more sensors is completely out of tau range, all
        % ShiftedTaunIndex will be NaN - this causes code to break
        
        if any(all(isnan(DataTemp)))
            whichsens      = find(all(all(isnan(DataTemp)),3));
            disp(['Program failure for penetration:  ' PenFileName '   ' ...
                newline newline ...
                'Check the following data to ensure program feasibility:' ...
                newline newline ...
                '- Ensure all input parameters are correct.' ...
                newline newline ...
                '- Ensure bottom water is correct.' ...
                newline newline ...
                ['- Ensure bad data is ignored. To ignore spurious data, ' ...
                'you may need to move the timing of events such as the ' ...
                'start of penetration, heat pulse, or end of penetration.' ...
                ' Use the text boxes in the command window to left.'] ...
                newline newline ...
                ['- If all paramters are correct and data time windows ' ...
                'are all correct, you may need to remove a sensor entirely. ' ...
                'If a sensor did not penetrate and was recording bottom ' ...
                'water temperature, the program could fail. This sensor ' ...
                'has no measurements in the required \tau range: '] ...
                num2str(whichsens) newline ['You may need to discard all ' ...
                'data from this sensor to proceed.'] newline newline  ...
                '- Finally, ensure data is within required \tau range. ' ...
                'Check heat pulse power, as this affects \tau. ' ...
                'If the heat pulse power is too low, you must raise power ' ...
                'or ignore the heat pulse reduction. ' ...
                'For sensitivity analysis, check minimum thermal ' ...
                'conductivity values ' ...
                'for each sensor. Your minimum may be too low.' newline])
            HPTooLow = 1;
            return
        else
            HPTooLow = 0;
        end  
        


